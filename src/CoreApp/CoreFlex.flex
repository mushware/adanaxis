 // $Id: CoreFlex.flex,v 1.2 2002/03/04 22:30:49 southa Exp $
%{
/*
 * $Id: CoreFlex.flex,v 1.2 2002/03/04 22:30:49 southa Exp $
 * $Log: CoreFlex.flex,v $
 * Revision 1.2  2002/03/04 22:30:49  southa
 * Interpreter work
 *
 * Revision 1.1  2002/03/02 20:35:08  southa
 * Added flex and bison parser
 *
 * C++ file autogenerated by flex
 */

#include "CoreFlex.hp"
#include "CoreStandard.hp"
#include "CoreBisonDefs.hp"
#include "CoreScalar.hp"

#define YY_DECL int CoreFlex::Lex(CoreScalar *outScalar, void *inPtr)
%}

%option noyywrap

string      \"[^\n"]+\"
ws          [ \t]+
alpha       [A-Za-z]
dig         [0-9]
identifier  ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
num1        [-+]?{dig}+\.?([eE][-+]?{dig}+)?
num2        [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
number      {num1}|{num2}
operator    [-+/*]
eos	    [;\n]
 
%%

{ws}    /* skip blanks and tabs */

"/*"    {
        int c;

        while((c = yyinput()) != 0)
            {
                if(c == '*')
                {
                    if((c = yyinput()) == '/')
                        break;
                    else
                        unput(c);
                }
            }
        }

{identifier} {
    IFFLEXTESTING(cerr << "identifier='" << yytext << "'" << endl);
    *outScalar=yytext;
    return IDENTIFIER;
}

{string} {
    IFFLEXTESTING(cerr << "string='" << yytext << "'" << endl);
    *outScalar=string(&yytext[1], strlen(yytext)-2);
    return STRING;
}

{eos} {
    IFFLEXTESTING(cerr << "EOS" << endl);
    return EOS;
}

<<EOF>> {
    IFFLEXTESTING(cerr << "EOF" << endl);
    return 0;
}


%%

CoreFlex::CoreFlex(const string& inStr): m_scalar(0)
{
    m_buffer_state=yy_scan_bytes(inStr.c_str(), inStr.size());
    if (m_buffer_state == NULL) throw "Flex failed";
}

