 // $Id: CoreFlex.flex,v 1.5 2002/03/08 22:48:14 southa Exp $
%{
/*
 * $Id: CoreFlex.flex,v 1.5 2002/03/08 22:48:14 southa Exp $
 * $Log: CoreFlex.flex,v $
 * Revision 1.5  2002/03/08 22:48:14  southa
 * Added first avarisse code
 *
 * Revision 1.4  2002/03/07 22:24:33  southa
 * Command interpreter working
 *
 * Revision 1.3  2002/03/05 22:44:46  southa
 * Changes to command handling
 *
 * Revision 1.2  2002/03/04 22:30:49  southa
 * Interpreter work
 *
 * Revision 1.1  2002/03/02 20:35:08  southa
 * Added flex and bison parser
 *
 * C++ file autogenerated by flex
 */

#include "CoreFlex.h"
#include "CoreStandard.h"
#include "CoreSwitches.h"
#include "CoreBisonDefs.h"
#include "CoreScalar.h"

#define YY_DECL int CoreFlex::Lex(CoreScalar *outScalar, void *inPtr)
%}

%option noyywrap

dstring     \"[^\n"]+\"
sstring     '[^\n']+'
string      {sstring}|{dstring}
ws          [ \t]+
alpha       [A-Za-z]
dig         [0-9]
url         (http|ftp):{unq_string}
piper       ->
identifier  ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
variable    \${identifier}
num1        [-+]?{dig}+\.?([eE][-+]?{dig}+)?
num2        [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
number      {num1}|{num2}
operator    [-+/*]
unq_string  [^\n; \t]+
eos	    [;\n]
 
%%

{ws}    /* skip blanks and tabs */

"/*"    {
        int c;

        while((c = yyinput()) != 0)
            {
                if(c == '*')
                {
                    if((c = yyinput()) == '/')
                        break;
                    else
                        unput(c);
                }
            }
        }

{url} {
    IFFLEXTESTING(cerr << "url='" << yytext << "'" << endl);
    *outScalar=yytext;
    return URL;
}

{piper} {
    IFFLEXTESTING(cerr << "piper" << endl);
    return PIPER;
}

{variable} {
    IFFLEXTESTING(cerr << "variable='" << yytext << "'" << endl);
    *outScalar=yytext;
    return VARIABLE;
}

{identifier} {
    IFFLEXTESTING(cerr << "identifier='" << yytext << "'" << endl);
    *outScalar=yytext;
    return IDENTIFIER;
}

{string} {
    IFFLEXTESTING(cerr << "string='" << yytext << "'" << endl);
    *outScalar=string(&yytext[1], strlen(yytext)-2);
    return STRING;
}

{unq_string} {
    IFFLEXTESTING(cerr << "unq_string='" << yytext << "'" << endl);
    *outScalar=yytext;
    return UNQUOTED_STRING;
}

{eos} {
    IFFLEXTESTING(cerr << "EOS" << endl);
    return EOS;
}

<<EOF>> {
    IFFLEXTESTING(cerr << "EOF" << endl);
    return 0;
}


%%

CoreFlex::CoreFlex(const string& inStr): m_scalar(0)
{
    m_buffer_state=yy_scan_bytes(inStr.c_str(), inStr.size());
    if (m_buffer_state == NULL) throw "Flex failed";
}

