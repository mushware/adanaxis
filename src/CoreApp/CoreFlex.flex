 // $Id: CoreFlex.flex,v 1.9 2002/07/02 14:27:12 southa Exp $
%{
/*
 * $Id: CoreFlex.flex,v 1.9 2002/07/02 14:27:12 southa Exp $
 * $Log: CoreFlex.flex,v $
 * Revision 1.9  2002/07/02 14:27:12  southa
 * First floor map designer build
 *
 * Revision 1.8  2002/05/30 14:41:15  southa
 * GameData and loadtilemap command
 *
 * Revision 1.7  2002/05/28 13:07:04  southa
 * Command parser extensions and TIFF loader
 *
 * Revision 1.6  2002/05/10 16:39:40  southa
 * Changed .hp files to .h
 *
 * Revision 1.5  2002/03/08 22:48:14  southa
 * Added first avarisse code
 *
 * Revision 1.4  2002/03/07 22:24:33  southa
 * Command interpreter working
 *
 * Revision 1.3  2002/03/05 22:44:46  southa
 * Changes to command handling
 *
 * Revision 1.2  2002/03/04 22:30:49  southa
 * Interpreter work
 *
 * Revision 1.1  2002/03/02 20:35:08  southa
 * Added flex and bison parser
 *
 * C++ file autogenerated by flex
 */

#include "CoreFlex.h"
#include "CoreStandard.h"
#include "CoreSwitches.h"
#include "CoreBisonDefs.h"
#include "CoreScalar.h"

#define YY_DECL int CoreFlex::Lex(CoreScalar *outScalar, void *inPtr)
%}

%option noyywrap

dstring     \"[^\n"]*\"
sstring     '[^\n']*'
string      {sstring}|{dstring}
ws          [ \t]+
alpha       [A-Za-z]
dig         [0-9]
identifier  ({alpha}|_)({alpha}|{dig}|_)*
variable    \${identifier}
num1        [-+]?{dig}+\.?([eE][-+]?{dig}+)?
num2        [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
number      {num1}|{num2}
eos	        [;\n]
comment     ^[ \t]*#.*
%%

{ws}      /* ignore whitespace */

{comment} /* ignore comment */
        
","     {
            IFFLEXTESTING(cerr << "," << endl);
            return ',';
        }
        
"("     {
            IFFLEXTESTING(cerr << "(" << endl);
            return '(';
        }

")"     {
            IFFLEXTESTING(cerr << ")" << endl);
            return ')';
        }
                    
"+"     {
            IFFLEXTESTING(cerr << yytext << endl);
            return '+';
        }
                    
"/*"    {
        int c;

        while((c = yyinput()) != 0)
            {
                if(c == '*')
                {
                    if((c = yyinput()) == '/')
                        break;
                    else
                        unput(c);
                }
            }
        }

{variable} {
    IFFLEXTESTING(cerr << "variable='" << yytext << "'" << endl);
    *outScalar=yytext;
    return VARIABLE;
}

{identifier} {
    IFFLEXTESTING(cerr << "identifier='" << yytext << "'" << endl);
    *outScalar=yytext;
    return IDENTIFIER;
}

{number} {
    IFFLEXTESTING(cerr << "number='" << yytext << "'" << endl);
    *outScalar=yytext;
    return NUMBER;
}

{string} {
    IFFLEXTESTING(cerr << "string='" << yytext << "'" << endl);
    *outScalar=string(&yytext[1], strlen(yytext)-2);
    return STRING;
}

{eos} {
    IFFLEXTESTING(cerr << "EOS" << endl);
    return EOS;
}

<<EOF>> {
    IFFLEXTESTING(cerr << "EOF" << endl);
    if (!m_eofFound)
    {
        m_eofFound=true;
        return END_OF_FILE;
    }
    return 0;
}


%%

CoreFlex::CoreFlex(const string& inStr): m_scalar(0), m_eofFound(false)
{
    m_buffer_state=yy_scan_bytes(inStr.c_str(), inStr.size());
    if (m_buffer_state == NULL) throw "Flex failed";
}

